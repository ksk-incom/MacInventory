"""Bundle file generation for package restoration.

Generates executable bundle files following the pattern from
MACINVENTORY_IMPLEMENTATION_GUIDE.md Decision 4 - Bundle File Pattern.

Inspired by Homebrew's Brewfile, this module generates plain text files
that can be executed directly or manually reviewed and customized.

Bundle Types:
    - Brewfile: Homebrew packages (brew bundle install)
    - MASApps.txt: Mac App Store apps (mas install commands)
    - NPMGlobalPackages.txt: npm global packages
    - PipPackages.txt: pip packages
    - PipxPackages.txt: pipx applications
    - CargoPackages.txt: Rust cargo packages
    - GemPackages.txt: Ruby gems
    - GoPackages.txt: Go binaries
    - VSCodeExtensions.txt: VS Code extensions
    - CursorExtensions.txt: Cursor extensions
    - ZedExtensions.txt: Zed extensions
    - PythonVersions.txt: pyenv Python versions
    - NodeVersions.txt: nvm Node.js versions
    - RubyVersions.txt: rbenv Ruby versions
    - AsdfVersions.txt: asdf plugin versions

From Vision document - Bundle File Pattern:
    "Uses the 'bundle file' pattern from Homebrew - simple text files
    that can be executed directly, not proprietary formats."
"""

from datetime import datetime
from pathlib import Path
from typing import Any, Optional


def _get_header(title: str, description: str) -> str:
    """Generate a header comment for bundle files.

    Args:
        title: Title for the file
        description: Description of what this bundle does

    Returns:
        Formatted header string
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    return f"""# {title}
# Generated by MacInventory on {timestamp}
# {description}
#
"""


# =============================================================================
# Brewfile Generation
# =============================================================================

def generate_brewfile(
    homebrew_data: dict[str, Any],
    include_versions: bool = False
) -> str:
    """Generate a Brewfile from Homebrew scan results.

    Creates a standard Homebrew Brewfile that can be used with
    `brew bundle install`.

    Args:
        homebrew_data: Results from homebrew.scan()
        include_versions: Include version comments (default: False)

    Returns:
        Brewfile content as string
    """
    lines = [
        _get_header(
            "Brewfile",
            "Install with: brew bundle install --file=Brewfile"
        )
    ]

    # Add taps first
    taps = homebrew_data.get("taps", [])
    if taps:
        lines.append("# Taps")
        for tap in sorted(taps):
            lines.append(f'tap "{tap}"')
        lines.append("")

    # Add formulae
    formulae = homebrew_data.get("formulae", [])
    if formulae:
        lines.append("# Formulae")
        for formula in sorted(formulae, key=lambda x: x.get("name", "").lower()):
            name = formula.get("name", "")
            if name:
                if include_versions and formula.get("version"):
                    lines.append(f'brew "{name}" # {formula["version"]}')
                else:
                    lines.append(f'brew "{name}"')
        lines.append("")

    # Add casks
    casks = homebrew_data.get("casks", [])
    if casks:
        lines.append("# Casks")
        for cask in sorted(casks, key=lambda x: x.get("name", "").lower()):
            name = cask.get("name", "")
            if name:
                if include_versions and cask.get("version"):
                    lines.append(f'cask "{name}" # {cask["version"]}')
                else:
                    lines.append(f'cask "{name}"')
        lines.append("")

    return "\n".join(lines)


def generate_mas_file(mas_data: dict[str, Any]) -> str:
    """Generate Mac App Store installation commands.

    Creates a text file with mas CLI commands to reinstall App Store apps.

    Args:
        mas_data: Results from homebrew.scan_mas()

    Returns:
        MAS installation script content
    """
    lines = [
        _get_header(
            "Mac App Store Applications",
            "Install mas first: brew install mas\n"
            "# Then run: while IFS= read -r line; do eval \"$line\"; done < MASApps.txt"
        )
    ]

    apps = mas_data.get("apps", [])
    if apps:
        for app in sorted(apps, key=lambda x: x.get("name", "").lower()):
            app_id = app.get("id", "")
            name = app.get("name", "Unknown")
            version = app.get("version", "")
            if app_id:
                version_comment = f" # {version}" if version else ""
                lines.append(f'mas install {app_id}  # {name}{version_comment}')

    if not apps:
        lines.append("# No Mac App Store applications found")

    return "\n".join(lines)


# =============================================================================
# Package Manager Bundle Generation
# =============================================================================

def generate_npm_file(npm_data: dict[str, Any]) -> str:
    """Generate npm global packages installation commands.

    Args:
        npm_data: Results from global_packages.scan_npm_global()

    Returns:
        NPM installation script content
    """
    lines = [
        _get_header(
            "NPM Global Packages",
            "Install with: npm install -g $(cat NPMGlobalPackages.txt | grep -v '^#' | tr '\\n' ' ')\n"
            "# Or install individually with version: npm install -g package@version"
        )
    ]

    packages = npm_data.get("packages", [])
    if packages:
        lines.append("# Package list (one per line)")
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            version = pkg.get("version", "")
            if name:
                if version:
                    lines.append(f"{name}@{version}")
                else:
                    lines.append(name)
    else:
        lines.append("# No npm global packages found")

    return "\n".join(lines)


def generate_pip_file(pip_data: dict[str, Any]) -> str:
    """Generate pip packages requirements file.

    Args:
        pip_data: Results from global_packages.scan_pip()

    Returns:
        Requirements.txt style content
    """
    lines = [
        _get_header(
            "Python Packages (pip)",
            "Install with: pip install -r PipPackages.txt\n"
            "# Or: pip install --user -r PipPackages.txt"
        )
    ]

    packages = pip_data.get("packages", [])
    if packages:
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            version = pkg.get("version", "")
            if name:
                if version:
                    lines.append(f"{name}=={version}")
                else:
                    lines.append(name)
    else:
        lines.append("# No pip packages found")

    return "\n".join(lines)


def generate_pipx_file(pipx_data: dict[str, Any]) -> str:
    """Generate pipx applications installation commands.

    Args:
        pipx_data: Results from global_packages.scan_pipx()

    Returns:
        Pipx installation script content
    """
    lines = [
        _get_header(
            "Pipx Applications",
            "Install pipx first: brew install pipx && pipx ensurepath\n"
            "# Then run: while IFS= read -r line; do [[ \"$line\" =~ ^#.*$ ]] || pipx install \"$line\"; done < PipxPackages.txt"
        )
    ]

    packages = pipx_data.get("packages", [])
    if packages:
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            version = pkg.get("version", "")
            if name:
                version_comment = f"  # {version}" if version else ""
                lines.append(f"{name}{version_comment}")
    else:
        lines.append("# No pipx applications found")

    return "\n".join(lines)


def generate_cargo_file(cargo_data: dict[str, Any]) -> str:
    """Generate cargo packages installation commands.

    Args:
        cargo_data: Results from global_packages.scan_cargo()

    Returns:
        Cargo installation script content
    """
    lines = [
        _get_header(
            "Cargo Packages (Rust)",
            "Install Rust first: curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"
            "# Then run: while IFS= read -r line; do [[ \"$line\" =~ ^#.*$ ]] || cargo install \"$line\"; done < CargoPackages.txt"
        )
    ]

    packages = cargo_data.get("packages", [])
    if packages:
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            version = pkg.get("version", "")
            if name:
                version_comment = f"  # {version}" if version else ""
                lines.append(f"{name}{version_comment}")
    else:
        lines.append("# No cargo packages found")

    return "\n".join(lines)


def generate_gem_file(gem_data: dict[str, Any]) -> str:
    """Generate gem packages installation commands.

    Args:
        gem_data: Results from global_packages.scan_gem()

    Returns:
        Gem installation script content
    """
    lines = [
        _get_header(
            "Ruby Gems",
            "Install with: gem install $(cat GemPackages.txt | grep -v '^#' | tr '\\n' ' ')\n"
            "# Or install with specific versions using gem install name -v version"
        )
    ]

    packages = gem_data.get("packages", [])
    if packages:
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            version = pkg.get("version", "")
            if name:
                version_comment = f"  # {version}" if version else ""
                lines.append(f"{name}{version_comment}")
    else:
        lines.append("# No Ruby gems found")

    return "\n".join(lines)


def generate_go_file(go_data: dict[str, Any]) -> str:
    """Generate Go packages installation commands.

    Args:
        go_data: Results from global_packages.scan_go()

    Returns:
        Go installation script content
    """
    lines = [
        _get_header(
            "Go Packages",
            "Note: Go packages are typically installed via 'go install path@version'\n"
            "# This file lists installed binaries - you may need to find the original import paths"
        )
    ]

    packages = go_data.get("packages", [])
    if packages:
        lines.append("# Installed Go binaries (may need to find original import paths)")
        for pkg in sorted(packages, key=lambda x: x.get("name", "").lower()):
            name = pkg.get("name", "")
            if name:
                lines.append(f"# {name}")
    else:
        lines.append("# No Go packages found")

    return "\n".join(lines)


# =============================================================================
# Editor Extension Bundle Generation
# =============================================================================

def generate_vscode_extensions_file(
    vscode_data: dict[str, Any],
    profile: Optional[str] = None
) -> str:
    """Generate VS Code extension installation commands.

    Args:
        vscode_data: Results from editors.scan_vscode()
        profile: Specific profile to generate for (default: all profiles)

    Returns:
        VS Code extension installation script
    """
    lines = [
        _get_header(
            "VS Code Extensions",
            "Install with: while IFS= read -r ext; do [[ \"$ext\" =~ ^#.*$ ]] || code --install-extension \"$ext\"; done < VSCodeExtensions.txt\n"
            "# For specific profile: code --profile \"ProfileName\" --install-extension extension.id"
        )
    ]

    profiles = vscode_data.get("profiles", [])
    if profiles:
        for prof in profiles:
            profile_name = prof.get("name", "Default")
            if profile and profile_name != profile:
                continue

            extensions = prof.get("extensions", [])
            if extensions:
                lines.append(f"# Profile: {profile_name} ({len(extensions)} extensions)")
                for ext in sorted(extensions, key=lambda x: x.get("id", "").lower()):
                    ext_id = ext.get("id", "")
                    version = ext.get("version", "")
                    if ext_id:
                        version_comment = f"  # {version}" if version else ""
                        lines.append(f"{ext_id}{version_comment}")
                lines.append("")
    else:
        lines.append("# No VS Code extensions found")

    return "\n".join(lines)


def generate_cursor_extensions_file(cursor_data: dict[str, Any]) -> str:
    """Generate Cursor extension installation commands.

    Args:
        cursor_data: Results from editors.scan_cursor()

    Returns:
        Cursor extension installation script
    """
    lines = [
        _get_header(
            "Cursor Extensions",
            "Install with: while IFS= read -r ext; do [[ \"$ext\" =~ ^#.*$ ]] || cursor --install-extension \"$ext\"; done < CursorExtensions.txt"
        )
    ]

    profiles = cursor_data.get("profiles", [])
    if profiles:
        for prof in profiles:
            profile_name = prof.get("name", "Default")
            extensions = prof.get("extensions", [])
            if extensions:
                lines.append(f"# Profile: {profile_name} ({len(extensions)} extensions)")
                for ext in sorted(extensions, key=lambda x: x.get("id", "").lower()):
                    ext_id = ext.get("id", "")
                    version = ext.get("version", "")
                    if ext_id:
                        version_comment = f"  # {version}" if version else ""
                        lines.append(f"{ext_id}{version_comment}")
                lines.append("")
    else:
        lines.append("# No Cursor extensions found")

    return "\n".join(lines)


def generate_zed_extensions_file(zed_data: dict[str, Any]) -> str:
    """Generate Zed extension list.

    Args:
        zed_data: Results from editors.scan_zed()

    Returns:
        Zed extension list content
    """
    lines = [
        _get_header(
            "Zed Extensions",
            "Zed extensions are installed via the Extensions panel (Cmd+Shift+X)\n"
            "# This file lists installed extensions for reference"
        )
    ]

    extensions = zed_data.get("extensions", [])
    if extensions:
        for ext in sorted(extensions, key=lambda x: x.get("id", "").lower()):
            ext_id = ext.get("id", "")
            if ext_id:
                lines.append(ext_id)
    else:
        lines.append("# No Zed extensions found")

    return "\n".join(lines)


# =============================================================================
# Version Manager Bundle Generation
# =============================================================================

def generate_python_versions_file(pyenv_data: dict[str, Any]) -> str:
    """Generate pyenv Python versions installation commands.

    Args:
        pyenv_data: Results from version_managers.scan_pyenv()

    Returns:
        Pyenv installation script content
    """
    lines = [
        _get_header(
            "Python Versions (pyenv)",
            "Install pyenv first: brew install pyenv\n"
            "# Add to shell: eval \"$(pyenv init -)\"\n"
            "# Then run: while IFS= read -r ver; do [[ \"$ver\" =~ ^#.*$ ]] || pyenv install \"$ver\"; done < PythonVersions.txt"
        )
    ]

    versions = pyenv_data.get("versions", [])
    global_version = pyenv_data.get("global_version")

    if versions:
        if global_version:
            lines.append(f"# Global version: {global_version}")
            lines.append("")

        lines.append("# Installed versions:")
        for ver in sorted(versions):
            marker = " (global)" if ver == global_version else ""
            lines.append(f"{ver}{marker}")
    else:
        lines.append("# No Python versions found via pyenv")

    return "\n".join(lines)


def generate_node_versions_file(nvm_data: dict[str, Any]) -> str:
    """Generate nvm Node.js versions installation commands.

    Args:
        nvm_data: Results from version_managers.scan_nvm()

    Returns:
        NVM installation script content
    """
    lines = [
        _get_header(
            "Node.js Versions (nvm)",
            "Install nvm first: brew install nvm\n"
            "# Add to shell: export NVM_DIR=\"$HOME/.nvm\" && source \"$(brew --prefix nvm)/nvm.sh\"\n"
            "# Then run: while IFS= read -r ver; do [[ \"$ver\" =~ ^#.*$ ]] || nvm install \"$ver\"; done < NodeVersions.txt"
        )
    ]

    versions = nvm_data.get("versions", [])
    default_version = nvm_data.get("default_version")

    if versions:
        if default_version:
            lines.append(f"# Default version: {default_version}")
            lines.append("")

        lines.append("# Installed versions:")
        for ver in versions:  # Already sorted in scanner
            marker = " (default)" if ver == default_version else ""
            lines.append(f"{ver}{marker}")
    else:
        lines.append("# No Node.js versions found via nvm")

    return "\n".join(lines)


def generate_ruby_versions_file(rbenv_data: dict[str, Any]) -> str:
    """Generate rbenv Ruby versions installation commands.

    Args:
        rbenv_data: Results from version_managers.scan_rbenv()

    Returns:
        Rbenv installation script content
    """
    lines = [
        _get_header(
            "Ruby Versions (rbenv)",
            "Install rbenv first: brew install rbenv ruby-build\n"
            "# Add to shell: eval \"$(rbenv init -)\"\n"
            "# Then run: while IFS= read -r ver; do [[ \"$ver\" =~ ^#.*$ ]] || rbenv install \"$ver\"; done < RubyVersions.txt"
        )
    ]

    versions = rbenv_data.get("versions", [])
    global_version = rbenv_data.get("global_version")

    if versions:
        if global_version:
            lines.append(f"# Global version: {global_version}")
            lines.append("")

        lines.append("# Installed versions:")
        for ver in sorted(versions):
            marker = " (global)" if ver == global_version else ""
            lines.append(f"{ver}{marker}")
    else:
        lines.append("# No Ruby versions found via rbenv")

    return "\n".join(lines)


def generate_asdf_versions_file(asdf_data: dict[str, Any]) -> str:
    """Generate asdf plugin versions installation commands.

    Args:
        asdf_data: Results from version_managers.scan_asdf()

    Returns:
        Asdf installation script content
    """
    lines = [
        _get_header(
            "asdf Versions",
            "Install asdf first: brew install asdf\n"
            "# Add to shell: source $(brew --prefix asdf)/libexec/asdf.sh\n"
            "# Install plugins: asdf plugin add <name>\n"
            "# Install versions: asdf install <plugin> <version>"
        )
    ]

    plugins = asdf_data.get("plugins", {})
    global_versions = asdf_data.get("global_versions", {})

    if plugins:
        for plugin_name, plugin_data in sorted(plugins.items()):
            versions = plugin_data.get("versions", [])
            if versions:
                global_ver = global_versions.get(plugin_name, "")
                lines.append(f"# Plugin: {plugin_name}")
                if global_ver:
                    lines.append(f"# Global: {global_ver}")
                for ver in sorted(versions):
                    marker = " (global)" if ver == global_ver else ""
                    lines.append(f"asdf install {plugin_name} {ver}{marker}")
                lines.append("")
    else:
        lines.append("# No asdf plugins or versions found")

    return "\n".join(lines)


# =============================================================================
# High-Level Bundle Generation
# =============================================================================

def generate_all_bundles(
    output_dir: Path,
    scan_results: dict[str, Any]
) -> dict[str, Any]:
    """Generate all bundle files from scan results.

    Args:
        output_dir: Output directory (should have bundles/ subdirectory)
        scan_results: Combined results from all scanners

    Returns:
        Dictionary with generation results and paths
    """
    bundles_dir = output_dir / "bundles"
    bundles_dir.mkdir(parents=True, exist_ok=True)

    generated: dict[str, Any] = {
        "files": [],
        "errors": [],
    }

    def write_bundle(filename: str, content: str) -> None:
        """Helper to write a bundle file and track result."""
        try:
            path = bundles_dir / filename
            path.write_text(content)
            # Count non-empty, non-comment lines
            lines = [line for line in content.split("\n") if line.strip() and not line.strip().startswith("#")]
            generated["files"].append({
                "filename": filename,
                "path": str(path),
                "items": len(lines),
            })
        except OSError as e:
            generated["errors"].append({
                "filename": filename,
                "error": str(e),
            })

    # Homebrew
    homebrew = scan_results.get("homebrew", {})
    if homebrew:
        write_bundle("Brewfile", generate_brewfile(homebrew))

    # Mac App Store
    mas = scan_results.get("mas", {})
    if mas:
        write_bundle("MASApps.txt", generate_mas_file(mas))

    # Global packages
    global_packages = scan_results.get("global_packages", {})
    if global_packages:
        npm = global_packages.get("npm", {})
        if npm.get("installed"):
            write_bundle("NPMGlobalPackages.txt", generate_npm_file(npm))

        pip = global_packages.get("pip", {})
        if pip.get("installed"):
            write_bundle("PipPackages.txt", generate_pip_file(pip))

        pipx = global_packages.get("pipx", {})
        if pipx.get("installed"):
            write_bundle("PipxPackages.txt", generate_pipx_file(pipx))

        cargo = global_packages.get("cargo", {})
        if cargo.get("installed"):
            write_bundle("CargoPackages.txt", generate_cargo_file(cargo))

        gem = global_packages.get("gem", {})
        if gem.get("installed"):
            write_bundle("GemPackages.txt", generate_gem_file(gem))

        go = global_packages.get("go", {})
        if go.get("installed"):
            write_bundle("GoPackages.txt", generate_go_file(go))

    # Editors
    editors = scan_results.get("editors", {})
    if editors:
        vscode = editors.get("vscode", {})
        if vscode.get("installed"):
            write_bundle("VSCodeExtensions.txt", generate_vscode_extensions_file(vscode))

        cursor = editors.get("cursor", {})
        if cursor.get("installed"):
            write_bundle("CursorExtensions.txt", generate_cursor_extensions_file(cursor))

        zed = editors.get("zed", {})
        if zed.get("installed"):
            write_bundle("ZedExtensions.txt", generate_zed_extensions_file(zed))

    # Version managers
    version_managers = scan_results.get("version_managers", {})
    if version_managers:
        pyenv = version_managers.get("pyenv", {})
        if pyenv.get("installed"):
            write_bundle("PythonVersions.txt", generate_python_versions_file(pyenv))

        nvm = version_managers.get("nvm", {})
        if nvm.get("installed"):
            write_bundle("NodeVersions.txt", generate_node_versions_file(nvm))

        rbenv = version_managers.get("rbenv", {})
        if rbenv.get("installed"):
            write_bundle("RubyVersions.txt", generate_ruby_versions_file(rbenv))

        asdf = version_managers.get("asdf", {})
        if asdf.get("installed"):
            write_bundle("AsdfVersions.txt", generate_asdf_versions_file(asdf))

    return generated


if __name__ == "__main__":
    import json
    import tempfile

    # Demo bundle generation with mock data
    mock_homebrew = {
        "taps": ["homebrew/cask", "homebrew/core"],
        "formulae": [
            {"name": "git", "version": "2.43.0"},
            {"name": "python@3.12", "version": "3.12.1"},
        ],
        "casks": [
            {"name": "visual-studio-code", "version": "1.85.0"},
            {"name": "docker", "version": "4.26.1"},
        ],
    }

    mock_npm = {
        "installed": True,
        "packages": [
            {"name": "typescript", "version": "5.3.3"},
            {"name": "eslint", "version": "8.56.0"},
        ],
    }

    print("=== Brewfile Preview ===")
    print(generate_brewfile(mock_homebrew))

    print("\n=== NPM Packages Preview ===")
    print(generate_npm_file(mock_npm))

    # Test full generation
    with tempfile.TemporaryDirectory() as tmpdir:
        output_dir = Path(tmpdir)
        mock_results = {
            "homebrew": mock_homebrew,
            "global_packages": {"npm": mock_npm},
        }

        result = generate_all_bundles(output_dir, mock_results)
        print("\n=== Generated Files ===")
        print(json.dumps(result, indent=2))
